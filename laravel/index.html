<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>vuepress</title>
    <meta name="description" content="vuepress">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/vuepress/assets/css/0.styles.9d29ff92.css" as="style"><link rel="preload" href="/vuepress/assets/js/app.6aa747de.js" as="script"><link rel="preload" href="/vuepress/assets/js/3.fb5d25fe.js" as="script"><link rel="preload" href="/vuepress/assets/js/9.3697497e.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/10.a7c60c6d.js"><link rel="prefetch" href="/vuepress/assets/js/11.2639e0d3.js"><link rel="prefetch" href="/vuepress/assets/js/12.60ab143f.js"><link rel="prefetch" href="/vuepress/assets/js/13.a676eb9a.js"><link rel="prefetch" href="/vuepress/assets/js/14.fe4097f0.js"><link rel="prefetch" href="/vuepress/assets/js/15.99f409ad.js"><link rel="prefetch" href="/vuepress/assets/js/2.6a8e1b92.js"><link rel="prefetch" href="/vuepress/assets/js/4.f57b0cc6.js"><link rel="prefetch" href="/vuepress/assets/js/5.d674bb53.js"><link rel="prefetch" href="/vuepress/assets/js/6.58332997.js"><link rel="prefetch" href="/vuepress/assets/js/7.115af17c.js"><link rel="prefetch" href="/vuepress/assets/js/8.91f43b16.js">
    <link rel="stylesheet" href="/vuepress/assets/css/0.styles.9d29ff92.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><div class="content__default"><h2 id="laravel"><a href="#laravel" class="header-anchor">#</a> Laravel</h2> <div class="language-md extra-class"><pre class="language-md"><code>composer create-project laravel/laravel folder<span class="token italic"><span class="token punctuation">_</span><span class="token content">name
composer create-project laravel/laravel folder</span><span class="token punctuation">_</span></span>name --prefer-dist &quot;5.8.*&quot;
composer install
composer install --prefer-dist
composer update
composer update package/name
composer dump-autoload [--optimize]
composer self-update
composer require <span class="token url">[<span class="token content">options</span>] [<span class="token variable">--</span>]</span> [vendor/packages]...
// 全局安装
composer require global vendor/packages
// 罗列所有扩展包括版本信息
composer show</code></pre></div><div class="language-md extra-class"><pre class="language-md"><code>基础使用 
// 定义一个 Eloquent 模型
class User extends Model {}
// 生成一个 Eloquent 模型
php artisan make:model User
// 生成一个 Eloquent 模型的时候，顺便生成迁移文件
php artisan make:model User --migration OR -m
// 生成一个 Eloquent 模型的时候，顺便生成迁移文件、控制器（或资源控制器）
php artisan make:model User -mc[r]
// 指定一个自定义的数据表名称
class User extends Model {
  protected $table = 'my<span class="token italic"><span class="token punctuation">_</span><span class="token content">users';
}
More
Model::create(array('key' =&gt; 'value'));
// 通过属性找到第一条相匹配的数据或创造一条新数据
Model::firstOrCreate(array('key' =&gt; 'value'));
// 通过属性找到第一条相匹配的数据或实例化一条新数据
Model::firstOrNew(array('key' =&gt; 'value'));
// 通过属性找到相匹配的数据并更新，如果不存在即创建
Model::updateOrCreate(array('search</span><span class="token punctuation">_</span></span>key' =&gt; 'search<span class="token italic"><span class="token punctuation">_</span><span class="token content">value'), array('key' =&gt; 'value'));
// 使用属性的数组来填充一个模型, 用的时候要小心「Mass Assignment」安全问题 !
Model::fill($attributes);
Model::destroy(1);
Model::all();
Model::find(1);
// 使用双主键进行查找
Model::find(array('first', 'last'));
// 查找失败时抛出异常
Model::findOrFail(1);
// 使用双主键进行查找, 失败时抛出异常
Model::findOrFail(array('first', 'last'));
Model::where('foo', '=', 'bar')-&gt;get();
Model::where('foo', '=', 'bar')-&gt;first();
Model::where('foo', '=', 'bar')-&gt;exists();
// 动态属性查找
Model::whereFoo('bar')-&gt;first();
// 查找失败时抛出异常
Model::where('foo', '=', 'bar')-&gt;firstOrFail();
Model::where('foo', '=', 'bar')-&gt;count();
Model::where('foo', '=', 'bar')-&gt;delete();
// 输出原始的查询语句
Model::where('foo', '=', 'bar')-&gt;toSql();
Model::whereRaw('foo = bar and cars = 2', array(20))-&gt;get();
Model::on('connection-name')-&gt;find(1);
Model::with('relation')-&gt;get();
Model::all()-&gt;take(10);
Model::all()-&gt;skip(10);
// 默认的 Eloquent 排序是上升排序
Model::all()-&gt;orderBy('column');
Model::all()-&gt;orderBy('column','desc');
// 查询 json 数据
Model::where('options-&gt;language', 'en')-&gt;get(); # 字段是字符串
Model::whereJsonContains('options-&gt;languages', 'en')-&gt;get(); # 字段是数组
Model::whereJsonLength('options-&gt;languages', 0)-&gt;get(); # 字段长度为 0
Model::whereJsonDoesntContain('options-&gt;languages', 'en')-&gt;get(); # 字段是数组, 不包含
软删除 
Model::withTrashed()-&gt;where('cars', 2)-&gt;get();
// 在查询结果中包括带被软删除的模型
Model::withTrashed()-&gt;where('cars', 2)-&gt;restore();
Model::where('cars', 2)-&gt;forceDelete();
// 查找只带有软删除的模型
Model::onlyTrashed()-&gt;where('cars', 2)-&gt;get();
模型关联
// 一对一 - User::phone()
return $this-&gt;hasOne('App\Phone', 'foreign</span><span class="token punctuation">_</span></span>key', 'local<span class="token italic"><span class="token punctuation">_</span><span class="token content">key');
// 一对一 - Phone::user(), 定义相对的关联
return $this-&gt;belongsTo('App\User', 'foreign</span><span class="token punctuation">_</span></span>key', 'other_key');

// 一对多 - Post::comments()
return $this-&gt;hasMany('App\Comment', 'foreign<span class="token italic"><span class="token punctuation">_</span><span class="token content">key', 'local</span><span class="token punctuation">_</span></span>key');
//  一对多 - Comment::post()
return $this-&gt;belongsTo('App\Post', 'foreign<span class="token italic"><span class="token punctuation">_</span><span class="token content">key', 'other</span><span class="token punctuation">_</span></span>key');

// 多对多 - User::roles();
return $this-&gt;belongsToMany('App\Role', 'user<span class="token italic"><span class="token punctuation">_</span><span class="token content">roles', 'user</span><span class="token punctuation">_</span></span>id', 'role<span class="token italic"><span class="token punctuation">_</span><span class="token content">id');
// 多对多 - Role::users();
return $this-&gt;belongsToMany('App\User');
// 多对多 - Retrieving Intermediate Table Columns
$role-&gt;pivot-&gt;created</span><span class="token punctuation">_</span></span>at;
// 多对多 - 中介表字段
return $this-&gt;belongsToMany('App\Role')-&gt;withPivot('column1', 'column2');
// 多对多 - 自动维护 created<span class="token italic"><span class="token punctuation">_</span><span class="token content">at 和 updated</span><span class="token punctuation">_</span></span>at 时间戳
return $this-&gt;belongsToMany('App\Role')-&gt;withTimestamps();

// 远层一对多 - Country::posts(), 一个 Country 模型可能通过中介的 Users
// 模型关联到多个 Posts 模型(User::country<span class="token italic"><span class="token punctuation">_</span><span class="token content">id)
return $this-&gt;hasManyThrough('App\Post', 'App\User', 'country</span><span class="token punctuation">_</span></span>id', 'user_id');

// 多态关联 - Photo::imageable()
return $this-&gt;morphTo();
// 多态关联 - Staff::photos()
return $this-&gt;morphMany('App\Photo', 'imageable');
// 多态关联 - Product::photos()
return $this-&gt;morphMany('App\Photo', 'imageable');
// 多态关联 - 在 AppServiceProvider 中注册你的「多态对照表」
Relation::morphMap([
    'Post' =&gt; App\Post::class,
    'Comment' =&gt; App\Comment::class,
]);

// 多态多对多关联 - 涉及数据库表: posts,videos,tags,taggables
// Post::tags()
return $this-&gt;morphToMany('App\Tag', 'taggable');
// Video::tags()
return $this-&gt;morphToMany('App\Tag', 'taggable');
// Tag::posts()
return $this-&gt;morphedByMany('App\Post', 'taggable');
// Tag::videos()
return $this-&gt;morphedByMany('App\Video', 'taggable');

// 查找关联
$user-&gt;posts()-&gt;where('active', 1)-&gt;get();
// 获取所有至少有一篇评论的文章...
$posts = App\Post::has('comments')-&gt;get();
// 获取所有至少有三篇评论的文章...
$posts = Post::has('comments', '&gt;=', 3)-&gt;get();
// 获取所有至少有一篇评论被评分的文章...
$posts = Post::has('comments.votes')-&gt;get();
// 获取所有至少有一篇评论相似于 foo% 的文章
$posts = Post::whereHas('comments', function ($query) {
    $query-&gt;where('content', 'like', 'foo%');
})-&gt;get();

// 预加载
$books = App\Book::with('author')-&gt;get();
$books = App\Book::with('author', 'publisher')-&gt;get();
$books = App\Book::with('author.contacts')-&gt;get();

// 延迟预加载
$books-&gt;load('author', 'publisher');

// 写入关联模型
$comment = new App\Comment(['message' =&gt; 'A new comment.']);
$post-&gt;comments()-&gt;save($comment);
// Save 与多对多关联
$post-&gt;comments()-&gt;saveMany([
    new App\Comment(['message' =&gt; 'A new comment.']),
    new App\Comment(['message' =&gt; 'Another comment.']),
]);
$post-&gt;comments()-&gt;create(['message' =&gt; 'A new comment.']);

// 更新「从属」关联
$user-&gt;account()-&gt;associate($account);
$user-&gt;save();
$user-&gt;account()-&gt;dissociate();
$user-&gt;save();

// 附加多对多关系
$user-&gt;roles()-&gt;attach($roleId);
$user-&gt;roles()-&gt;attach($roleId, ['expires' =&gt; $expires]);
// 从用户上移除单一身份...
$user-&gt;roles()-&gt;detach($roleId);
// 从用户上移除所有身份...
$user-&gt;roles()-&gt;detach();
$user-&gt;roles()-&gt;detach([1, 2, 3]);
$user-&gt;roles()-&gt;attach([1 =&gt; ['expires' =&gt; $expires], 2, 3]);

// 任何不在给定数组中的 IDs 将会从中介表中被删除。
$user-&gt;roles()-&gt;sync([1, 2, 3]);
// 你也可以传递中介表上该 IDs 额外的值：
$user-&gt;roles()-&gt;sync([1 =&gt; ['expires' =&gt; true], 2, 3]);
事件
Model::retrieved(function($model){});
Model::creating(function($model){});
Model::created(function($model){});
Model::updating(function($model){});
Model::updated(function($model){});
Model::saving(function($model){});
Model::saved(function($model){});
Model::deleting(function($model){});
Model::deleted(function($model){});
Model::restoring(function($model){});
Model::restored(function($model){});
Model::observe(new FooObserver);
Eloquent 配置信息
// 关闭模型插入或更新操作引发的 「mass assignment」异常
Eloquent::unguard();
// 重新开启「mass assignment」异常抛出功能
Eloquent::reguard()</code></pre></div><div class="language-md extra-class"><pre class="language-md"><code><span class="token code"><span class="token punctuation">```</span><span class="token code-language"> php</span>
<span class="token code-block language-php">注：数组和字串函数将在 5.9 全面废弃，推荐使用 Arr 和 Str Facade

数组 &amp; 对象
// 如果给定的键不存在于该数组，Arr::add 函数将给定的键值对加到数组中
Arr::add(['name' =&gt; 'Desk'], 'price', 100); 
// &gt;&gt;&gt; ['name' =&gt; 'Desk', 'price' =&gt; 100]
// 将数组的每一个数组折成单一数组
Arr::collapse([[1, 2, 3], [4, 5, 6]]);  
// &gt;&gt;&gt; [1, 2, 3, 4, 5, 6]
// 函数返回两个数组，一个包含原本数组的键，另一个包含原本数组的值
Arr::divide(['key1' =&gt; 'val1', 'key2' =&gt;'val2'])
// &gt;&gt;&gt; [[&quot;key1&quot;,&quot;key2&quot;],[&quot;val1&quot;,&quot;val2&quot;]]
// 把多维数组扁平化成一维数组，并用「点」式语法表示深度
Arr::dot($array);
// 从数组移除给定的键值对
Arr::except($array, array('key'));
// 返回数组中第一个通过为真测试的元素
Arr::first($array, function($key, $value){}, $default);
// 将多维数组扁平化成一维
 // ['Joe', 'PHP', 'Ruby'];
Arr::flatten(['name' =&gt; 'Joe', 'languages' =&gt; ['PHP', 'Ruby']]);
// 以「点」式语法从深度嵌套数组移除给定的键值对
Arr::forget($array, 'foo');
Arr::forget($array, 'foo.bar');
// 使用「点」式语法从深度嵌套数组取回给定的值
Arr::get($array, 'foo', 'default');
Arr::get($array, 'foo.bar', 'default');
// 使用「点」式语法检查给定的项目是否存在于数组中
Arr::has($array, 'products.desk');
// 从数组返回给定的键值对
Arr::only($array, array('key'));
// 从数组拉出一列给定的键值对
Arr::pluck($array, 'key');
// 从数组移除并返回给定的键值对
Arr::pull($array, 'key');
// 使用「点」式语法在深度嵌套数组中写入值
Arr::set($array, 'key', 'value');
Arr::set($array, 'key.subkey', 'value');
// 借由给定闭包结果排序数组
Arr::sort($array, function(){});
// 使用 sort 函数递归排序数组
Arr::sortRecursive();
// 使用给定的闭包过滤数组
Arr::where();
// 数组&quot;洗牌&quot;
Arr::shuffle($array,'I-AM-GROOT');
// 数组包裹(如果不是数组，就变成数组，如果是空的，返回[],否则返回原数据）
Arr::wrap($array);
// 返回给定数组的第一个元素
head($array);
// 返回给定数组的最后一个元素
last($array);
路径
// 取得 app 文件夹的完整路径
app_path();
// 取得项目根目录的完整路径
base_path();
// 取得应用配置目录的完整路径
config_path();
// 取得应用数据库目录的完整路径
database_path();
// 取得加上版本号的 Elixir 文件路径
elixir();
// 取得 public 目录的完整路径
public_path();
// 取得 storage 目录的完整路径
storage_path();
字符串
// 将给定的字符串转换成 驼峰式命名
Str::camel($value);
// 返回不包含命名空间的类名称
class_basename($class);
class_basename($object);
// 对给定字符串运行 htmlentities
e('&lt;html&gt;');
// 判断字符串开头是否为给定内容
Str::startsWith('Foo bar.', 'Foo');
// 判断给定字符串结尾是否为指定内容
Str::endsWith('Foo bar.', 'bar.');
// 将给定的字符串转换成 蛇形命名
Str::snake('fooBar');
// 将给定字符串转换成「首字大写命名」: FooBar
Str::studly('foo_bar');
// 根据你的本地化文件翻译给定的语句
trans('foo.bar');
// 根据后缀变化翻译给定的语句
trans_choice('foo.bar', $count);
URLs and Links
// 产生给定控制器行为网址
action('FooController@method', $parameters);
// 根据目前请求的协定（HTTP 或 HTTPS）产生资源文件网址
asset('img/photo.jpg', $title, $attributes);
// 根据 HTTPS 产生资源文件网址
secure_asset('img/photo.jpg', $title, $attributes);
// 产生给定路由名称网址
route($route, $parameters, $absolute = true);
// 产生给定路径的完整网址
url('path', $parameters = array(), $secure = null);
其他
// 返回一个认证器实例。你可以使用它取代 Auth facade
auth()-&gt;user();
// 产生一个重定向回应让用户回到之前的位置
back();
// 使用 Bcrypt 哈希给定的数值。你可以使用它替代 Hash facade
bcrypt('my-secret-password');
// 从给定的项目产生集合实例
collect(['taylor', 'abigail']);
// 取得设置选项的设置值
config('app.timezone', $default);
// 产生包含 CSRF 令牌内容的 HTML 表单隐藏字段
{!! csrf_field() !!} 
// 5.7+用这个
@csrf
// 取得当前 CSRF 令牌的内容
$token = csrf_token();
// 输出给定变量并结束脚本运行
dd($value);
// var_dump缩写（如果用dump-server,var_dump可能无效）
dump($value);
// 取得环境变量值或返回默认值
$env = env('APP_ENV');
$env = env('APP_ENV', 'production');
// 配送给定事件到所属的侦听器
event(new UserRegistered($user));
// 根据给定类、名称以及总数产生模型工厂建构器
$user = factory(App\User::class)-&gt;make();
// 产生拟造 HTTP 表单动作内容的 HTML 表单隐藏字段
{!! method_field('delete') !!}
// 5.7+
@method('delete')
// 取得快闪到 session 的旧有输入数值
$value = old('value');
$value = old('value', 'default');
// 返回重定向器实例以进行 重定向
 return redirect('/home');
// 取得目前的请求实例或输入的项目
$value = request('key', $default = null)
// 创建一个回应实例或获取一个回应工厂实例
return response('Hello World', 200, $headers);
// 可被用于取得或设置单一 session 内容
$value = session('key');
// 在没有传递参数时，将返回 session 实例
$value = session()-&gt;get('key');
session()-&gt;put('key', $value);
// 返回给定数值
value(function(){ return 'bar'; });
// 取得视图 实例
return view('auth.login');
// 返回给定的数值
$value = with(new Foo)-&gt;work();</span>
<span class="token punctuation">```</span></span></code></pre></div><div class="language-md extra-class"><pre class="language-md"><code>// 针对命令显示帮助信息
php artisan --help OR -h
// 抑制输出信息
php artisan --quiet OR -q
// 打印 Laravel 的版本信息
php artisan --version OR -V
// 不询问任何交互性的问题
php artisan --no-interaction OR -n
// 强制输出 ANSI 格式
php artisan --ansi
// 禁止输出 ANSI 格式
php artisan --no-ansi
// 显示当前命令行运行的环境
php artisan --env
// -v|vv|vvv 通过增加 v 的个数来控制命令行输出内容的详尽情况: 1 个代表正常输出, 2 个代表输出更多消息, 3 个代表调试
php artisan --verbose
// 移除编译优化过的文件 (storage/frameworks/compiled.php)
php artisan clear-compiled
// 显示当前框架运行的环境
php artisan env
// 显示某个命令的帮助信息
php artisan help
// 显示所有可用的命令
php artisan list
// 进入应用交互模式
php artisan tinker
// 配合 dump() 函数调试数据
php artisan dump-server
// 进入维护模式
php artisan down
// 退出维护模式
php artisan up
// 优化框架性能
 // --force    强制编译已写入文件 (storage/frameworks/compiled.php)
 // --psr      不对 Composer 的 dump-autoload 进行优化
php artisan optimize <span class="token url">[<span class="token content">--force</span>] [<span class="token variable">--psr</span>]</span>
// 更改前端预设
// type<span class="token italic"><span class="token punctuation">_</span><span class="token content">name (可以是 none, bootstrap, vue, react)
php artisan preset <span class="token url">[<span class="token content">options</span>] [<span class="token variable">--</span>]</span> type</span><span class="token punctuation">_</span></span>name
// 启动内置服务器
php artisan serve
// 更改默认端口
php artisan serve --port 8080
// 使其在本地服务器外也可正常工作
php artisan serve --host 0.0.0.0
// 更改应用命名空间
php artisan app:name namespace
// 清除过期的密码重置令牌
php artisan auth:clear-resets

// 清空应用缓存
php artisan cache:clear
// 移除 key<span class="token italic"><span class="token punctuation">_</span><span class="token content">name 对应的缓存
php artisan cache:forget key</span><span class="token punctuation">_</span></span>name [<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>store</span><span class="token punctuation">&gt;</span></span>]
// 创建缓存数据库表 migration
php artisan cache:table

// 合并所有的配置信息为一个，提高加载速度
php artisan config:cache
// 移除配置缓存文件
php artisan config:clear

// 程序内部调用 Artisan 命令
$exitCode = Artisan::call('config:cache');
// 运行所有的 seed 假数据生成类
 // --class      可以指定运行的类，默认是: &quot;DatabaseSeeder&quot;
 // --database   可以指定数据库
 // --force      当处于生产环境时强制执行操作
php artisan db:seed [--class[=&quot;...&quot;]] [--database[=&quot;...&quot;]] [--force]

// 基于注册的信息，生成遗漏的 events 和 handlers
php artisan event:generate
// 罗列所有事件和监听器
php artisan event:list
// 缓存事件和监听器
php artisan event:cache
// 清除事件和监听器缓存
php artisan event:clear

// 生成新的处理器类
 // --command      需要处理器处理的命令类名字
php artisan handler:command [--command=&quot;...&quot;] name
// 创建一个新的时间处理器类
 // --event        需要处理器处理的事件类名字
 // --queued       需要处理器使用队列话处理的事件类名字
php artisan handler:event <span class="token url">[<span class="token content">--event=&quot;...&quot;</span>] [<span class="token variable">--queued</span>]</span> name

// 生成应用的 key（会覆盖）
php artisan key:generate

// 发布本地化翻译文件到 resources 文件下
// locales: 逗号分隔，如 zh_CN,tk,th [默认是: &quot;all&quot;]
php artisan lang:publish <span class="token url">[<span class="token content">options</span>] [<span class="token variable">--</span>]</span> [<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>locales</span><span class="token punctuation">&gt;</span></span>]

// 创建用户认证脚手架
php artisan make:auth
// 创建 Channel 类
php artisan make:channel name
// 在默认情况下, 这将创建未加入队列的自处理命令
 // 通过 --handler 标识来生成一个处理器, 用 --queued 来使其入队列.
php artisan make:command <span class="token url">[<span class="token content">--handler</span>] [<span class="token variable">--queued</span>]</span> name
// 创建一个新的 Artisan 命令
 //  --command     命令被调用的名称。 (默认为: &quot;command:name&quot;)
php artisan make:console [--command[=&quot;...&quot;]] name
// 创建一个新的资源控制器
 // --plain      生成一个空白的控制器类
php artisan make:controller [--plain] name
php artisan make:controller App\\Admin\\Http\\Controllers\\DashboardController
// 创建一个新的事件类
php artisan make:event name
// 创建异常类
php artisan make:exception name
// 创建模型工厂类
php artisan make:factory name
// 创建一个队列任务文件
php artisan make:job 
// 创建一个监听者类
php artisan make:listener name
// 创建一个新的邮件类
php artisan make:mail name
// 创建一个新的中间件类
php artisan make:middleware name
// 创建一个新的迁移文件
 // --create     将被创建的数据表.
 // --table      将被迁移的数据表.
php artisan make:migration [--create[=&quot;...&quot;]] [--table[=&quot;...&quot;]] name
// 创建一个新的 Eloquent 模型类
php artisan make:model User
php artisan make:model Models/User
// 新建一个消息通知类
php artisan make:notification TopicRepliedNotification
// 新建一个模型观察者类
php artisan make:observer UserObserver
// 创建授权策略
php artisan make:policy PostPolicy
// 创建一个新的服务提供者类
php artisan make:provider name
// 创建一个新的表单请求类
php artisan make:request name
// 创建一个 API 资源类
php artisan make:resource name
// 新建验证规则类
php artisan make:rule name
// 创建模型脚手架
// <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">&gt;</span></span> 模型名称，如 Post
// -s, --schema=SCHEMA 表结构如：--schema=&quot;title:string&quot;
// -a, --validator[=VALIDATOR] 表单验证，如：--validator=&quot;title:required&quot;
// -l, --localization[=LOCALIZATION] 设置本地化信息，如：--localization=&quot;key:value&quot;
// -b, --lang[=LANG] 设置本地化语言 --lang=&quot;en&quot;
// -f, --form[=FORM] 使用 Illumintate/Html Form 来生成表单选项，默认为 false
// -p, --prefix[=PREFIX] 表结构前缀，默认 false
php artisan make:scaffold  <span class="token url">[<span class="token content">options</span>] [<span class="token variable">--</span>]</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">&gt;</span></span>
// 生成数据填充类
php artisan make:seeder
// 生成测试类
php artisan make:test

// 数据库迁移
 // --database   指定数据库连接（下同）
 // --force      当处于生产环境时强制执行，不询问（下同）
 // --path       指定单独迁移文件地址
 // --pretend    把将要运行的 SQL 语句打印出来（下同）
 // --seed       Seed 任务是否需要被重新运行（下同）
php artisan migrate [--database[=&quot;...&quot;]] <span class="token url">[<span class="token content">--force</span>] [<span class="token variable">--path[=&quot;...&quot;</span>]</span>] <span class="token url">[<span class="token content">--pretend</span>] [<span class="token variable">--seed</span>]</span>
// 创建迁移数据库表
php artisan migrate:install [--database[=&quot;...&quot;]]
// Drop 所有数据表并重新运行 Migration
php artisan migrate:fresh
// 重置并重新运行所有的 migrations
 // --seeder     指定主 Seeder 的类名
php artisan migrate:refresh [--database[=&quot;...&quot;]] <span class="token url">[<span class="token content">--force</span>] [<span class="token variable">--seed</span>]</span> [--seeder[=&quot;...&quot;]]
// 回滚所有的数据库迁移
php artisan migrate:reset [--database[=&quot;...&quot;]] <span class="token url">[<span class="token content">--force</span>] [<span class="token variable">--pretend</span>]</span>
// 回滚最最近一次运行的迁移任务
php artisan migrate:rollback [--database[=&quot;...&quot;]] <span class="token url">[<span class="token content">--force</span>] [<span class="token variable">--pretend</span>]</span>
// migrations 数据库表信息
php artisan migrate:status

// 为数据库消息通知创建一个表迁移类
php artisan notifications:table
// 清除缓存的 bootstrap 文件
php artisan optimize:clear
// 扩展包自动发现
php artisan package:discover

// 为队列数据库表创建一个新的迁移
php artisan queue:table
// 监听指定的队列
 // --queue      被监听的队列
 // --delay      给执行失败的任务设置延时时间 (默认为零: 0)
 // --memory     内存限制大小，单位为 MB (默认为: 128)
 // --timeout    指定任务运行超时秒数 (默认为: 60)
 // --sleep      等待检查队列任务的秒数 (默认为: 3)
 // --tries      任务记录失败重试次数 (默认为: 0)
php artisan queue:listen [--queue[=&quot;...&quot;]] [--delay[=&quot;...&quot;]] [--memory[=&quot;...&quot;]] [--timeout[=&quot;...&quot;]] [--sleep[=&quot;...&quot;]] [--tries[=&quot;...&quot;]] [connection]
// 查看所有执行失败的队列任务
php artisan queue:failed
// 为执行失败的数据表任务创建一个迁移
php artisan queue:failed-table
// 清除所有执行失败的队列任务
php artisan queue:flush
// 删除一个执行失败的队列任务
php artisan queue:forget
// 在当前的队列任务执行完毕后, 重启队列的守护进程
php artisan queue:restart
// 对指定 id 的执行失败的队列任务进行重试(id: 失败队列任务的 ID)
php artisan queue:retry id
// 指定订阅 Iron.io 队列的链接
 // queue: Iron.io 的队列名称.
 // url: 将被订阅的 URL.
 // --type       指定队列的推送类型.
php artisan queue:subscribe [--type[=&quot;...&quot;]] queue url
// 处理下一个队列任务
 // --queue      被监听的队列
 // --daemon     在后台模式运行
 // --delay      给执行失败的任务设置延时时间 (默认为零: 0)
 // --force      强制在「维护模式下」运行
 // --memory     内存限制大小，单位为 MB (默认为: 128)
 // --sleep      当没有任务处于有效状态时, 设置其进入休眠的秒数 (默认为: 3)
 // --tries      任务记录失败重试次数 (默认为: 0)
php artisan queue:work [--queue[=&quot;...&quot;]] <span class="token url">[<span class="token content">--daemon</span>] [<span class="token variable">--delay[=&quot;...&quot;</span>]</span>] <span class="token url">[<span class="token content">--force</span>] [<span class="token variable">--memory[=&quot;...&quot;</span>]</span>] [--sleep[=&quot;...&quot;]] [--tries[=&quot;...&quot;]] [connection]

// 生成路由缓存文件来提升路由效率
php artisan route:cache
// 移除路由缓存文件
php artisan route:clear
// 显示已注册过的路由
php artisan route:list

// 运行计划命令
php artisan schedule:run

// 为 session 数据表生成迁移文件
php artisan session:table
// 创建 &quot;public/storage&quot; 到 &quot;storage/app/public&quot; 的软链接
php artisan storage:link

// 从 vendor 的扩展包中发布任何可发布的资源
 // --force        重写所有已存在的文件
 // --provider     指定你想要发布资源文件的服务提供者
 // --tag          指定你想要发布标记资源.
php artisan vendor:publish <span class="token url">[<span class="token content">--force</span>] [<span class="token variable">--provider[=&quot;...&quot;</span>]</span>] [--tag[=&quot;...&quot;]]
php artisan tail [--path[=&quot;...&quot;]] [--lines[=&quot;...&quot;]] [connection]

// 缓存视图文件以提高效率
php artisan view:cache
// 清除视图文件缓存
php artisan view:clear</code></pre></div><div class="language-md extra-class"><pre class="language-md"><code>$environment = app()-&gt;environment();
$environment = App::environment();
// 判断当环境是否为 local
if (app()-&gt;environment('local')){}
// 判断当环境是否为 local 或 staging...
if (app()-&gt;environment(['local', 'staging'])){}</code></pre></div></div></div><div class="global-ui"></div></div>
    <script src="/vuepress/assets/js/app.6aa747de.js" defer></script><script src="/vuepress/assets/js/3.fb5d25fe.js" defer></script><script src="/vuepress/assets/js/9.3697497e.js" defer></script>
  </body>
</html>
