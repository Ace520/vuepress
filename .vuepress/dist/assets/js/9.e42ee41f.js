(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{160:function(n,a,e){"use strict";e.r(a);var p=e(28),t=Object(p.a)({},(function(){var n=this,a=n.$createElement,e=n._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("// 针对命令显示帮助信息\nphp artisan --help OR -h\n// 抑制输出信息\nphp artisan --quiet OR -q\n// 打印 Laravel 的版本信息\nphp artisan --version OR -V\n// 不询问任何交互性的问题\nphp artisan --no-interaction OR -n\n// 强制输出 ANSI 格式\nphp artisan --ansi\n// 禁止输出 ANSI 格式\nphp artisan --no-ansi\n// 显示当前命令行运行的环境\nphp artisan --env\n// -v|vv|vvv 通过增加 v 的个数来控制命令行输出内容的详尽情况: 1 个代表正常输出, 2 个代表输出更多消息, 3 个代表调试\nphp artisan --verbose\n// 移除编译优化过的文件 (storage/frameworks/compiled.php)\nphp artisan clear-compiled\n// 显示当前框架运行的环境\nphp artisan env\n// 显示某个命令的帮助信息\nphp artisan help\n// 显示所有可用的命令\nphp artisan list\n// 进入应用交互模式\nphp artisan tinker\n// 配合 dump() 函数调试数据\nphp artisan dump-server\n// 进入维护模式\nphp artisan down\n// 退出维护模式\nphp artisan up\n// 优化框架性能\n// --force    强制编译已写入文件 (storage/frameworks/compiled.php)\n// --psr      不对 Composer 的 dump-autoload 进行优化\nphp artisan optimize [--force] [--psr]\n// 更改前端预设\n// type_name (可以是 none, bootstrap, vue, react)\nphp artisan preset [options] [--] type_name\n// 启动内置服务器\nphp artisan serve\n// 更改默认端口\nphp artisan serve --port 8080\n// 使其在本地服务器外也可正常工作\nphp artisan serve --host 0.0.0.0\n// 更改应用命名空间\nphp artisan app:name namespace\n// 清除过期的密码重置令牌\nphp artisan auth:clear-resets")]),n._v(" "),e("p",[n._v("// 清空应用缓存\nphp artisan cache:clear\n// 移除 key_name 对应的缓存\nphp artisan cache:forget key_name ["),e("store",[n._v("]\n// 创建缓存数据库表 migration\nphp artisan cache:table")])],1),n._v(" "),e("p",[n._v("// 合并所有的配置信息为一个，提高加载速度\nphp artisan config:cache\n// 移除配置缓存文件\nphp artisan config:clear")]),n._v(" "),e("p",[n._v('// 程序内部调用 Artisan 命令\n$exitCode = Artisan::call(\'config:cache\');\n// 运行所有的 seed 假数据生成类\n// --class      可以指定运行的类，默认是: "DatabaseSeeder"\n// --database   可以指定数据库\n// --force      当处于生产环境时强制执行操作\nphp artisan db:seed [--class[="..."]] [--database[="..."]] [--force]')]),n._v(" "),e("p",[n._v("// 基于注册的信息，生成遗漏的 events 和 handlers\nphp artisan event:generate\n// 罗列所有事件和监听器\nphp artisan event:list\n// 缓存事件和监听器\nphp artisan event:cache\n// 清除事件和监听器缓存\nphp artisan event:clear")]),n._v(" "),e("p",[n._v('// 生成新的处理器类\n// --command      需要处理器处理的命令类名字\nphp artisan handler:command [--command="..."] name\n// 创建一个新的时间处理器类\n// --event        需要处理器处理的事件类名字\n// --queued       需要处理器使用队列话处理的事件类名字\nphp artisan handler:event [--event="..."] [--queued] name')]),n._v(" "),e("p",[n._v("// 生成应用的 key（会覆盖）\nphp artisan key:generate")]),n._v(" "),e("p",[n._v('// 发布本地化翻译文件到 resources 文件下\n// locales: 逗号分隔，如 zh_CN,tk,th [默认是: "all"]\nphp artisan lang:publish [options] [--] ['),e("locales",[n._v("]")])],1),n._v(" "),e("p",[n._v('// 创建用户认证脚手架\nphp artisan make:auth\n// 创建 Channel 类\nphp artisan make:channel name\n// 在默认情况下, 这将创建未加入队列的自处理命令\n// 通过 --handler 标识来生成一个处理器, 用 --queued 来使其入队列.\nphp artisan make:command [--handler] [--queued] name\n// 创建一个新的 Artisan 命令\n//  --command     命令被调用的名称。 (默认为: "command:name")\nphp artisan make:console [--command[="..."]] name\n// 创建一个新的资源控制器\n// --plain      生成一个空白的控制器类\nphp artisan make:controller [--plain] name\nphp artisan make:controller App\\Admin\\Http\\Controllers\\DashboardController\n// 创建一个新的事件类\nphp artisan make:event name\n// 创建异常类\nphp artisan make:exception name\n// 创建模型工厂类\nphp artisan make:factory name\n// 创建一个队列任务文件\nphp artisan make:job\n// 创建一个监听者类\nphp artisan make:listener name\n// 创建一个新的邮件类\nphp artisan make:mail name\n// 创建一个新的中间件类\nphp artisan make:middleware name\n// 创建一个新的迁移文件\n// --create     将被创建的数据表.\n// --table      将被迁移的数据表.\nphp artisan make:migration [--create[="..."]] [--table[="..."]] name\n// 创建一个新的 Eloquent 模型类\nphp artisan make:model User\nphp artisan make:model Models/User\n// 新建一个消息通知类\nphp artisan make:notification TopicRepliedNotification\n// 新建一个模型观察者类\nphp artisan make:observer UserObserver\n// 创建授权策略\nphp artisan make:policy PostPolicy\n// 创建一个新的服务提供者类\nphp artisan make:provider name\n// 创建一个新的表单请求类\nphp artisan make:request name\n// 创建一个 API 资源类\nphp artisan make:resource name\n// 新建验证规则类\nphp artisan make:rule name\n// 创建模型脚手架\n// '),e("name",[n._v(' 模型名称，如 Post\n// -s, --schema=SCHEMA 表结构如：--schema="title:string"\n// -a, --validator[=VALIDATOR] 表单验证，如：--validator="title:required"\n// -l, --localization[=LOCALIZATION] 设置本地化信息，如：--localization="key:value"\n// -b, --lang[=LANG] 设置本地化语言 --lang="en"\n// -f, --form[=FORM] 使用 Illumintate/Html Form 来生成表单选项，默认为 false\n// -p, --prefix[=PREFIX] 表结构前缀，默认 false\nphp artisan make:scaffold  [options] [--] '),e("name",[n._v("\n// 生成数据填充类\nphp artisan make:seeder\n// 生成测试类\nphp artisan make:test")])],1)],1),n._v(" "),e("p",[n._v('// 数据库迁移\n// --database   指定数据库连接（下同）\n// --force      当处于生产环境时强制执行，不询问（下同）\n// --path       指定单独迁移文件地址\n// --pretend    把将要运行的 SQL 语句打印出来（下同）\n// --seed       Seed 任务是否需要被重新运行（下同）\nphp artisan migrate [--database[="..."]] [--force] [--path[="..."]] [--pretend] [--seed]\n// 创建迁移数据库表\nphp artisan migrate:install [--database[="..."]]\n// Drop 所有数据表并重新运行 Migration\nphp artisan migrate:fresh\n// 重置并重新运行所有的 migrations\n// --seeder     指定主 Seeder 的类名\nphp artisan migrate:refresh [--database[="..."]] [--force] [--seed] [--seeder[="..."]]\n// 回滚所有的数据库迁移\nphp artisan migrate:reset [--database[="..."]] [--force] [--pretend]\n// 回滚最最近一次运行的迁移任务\nphp artisan migrate:rollback [--database[="..."]] [--force] [--pretend]\n// migrations 数据库表信息\nphp artisan migrate:status')]),n._v(" "),e("p",[n._v("// 为数据库消息通知创建一个表迁移类\nphp artisan notifications:table\n// 清除缓存的 bootstrap 文件\nphp artisan optimize:clear\n// 扩展包自动发现\nphp artisan package:discover")]),n._v(" "),e("p",[n._v('// 为队列数据库表创建一个新的迁移\nphp artisan queue:table\n// 监听指定的队列\n// --queue      被监听的队列\n// --delay      给执行失败的任务设置延时时间 (默认为零: 0)\n// --memory     内存限制大小，单位为 MB (默认为: 128)\n// --timeout    指定任务运行超时秒数 (默认为: 60)\n// --sleep      等待检查队列任务的秒数 (默认为: 3)\n// --tries      任务记录失败重试次数 (默认为: 0)\nphp artisan queue:listen [--queue[="..."]] [--delay[="..."]] [--memory[="..."]] [--timeout[="..."]] [--sleep[="..."]] [--tries[="..."]] [connection]\n// 查看所有执行失败的队列任务\nphp artisan queue:failed\n// 为执行失败的数据表任务创建一个迁移\nphp artisan queue:failed-table\n// 清除所有执行失败的队列任务\nphp artisan queue:flush\n// 删除一个执行失败的队列任务\nphp artisan queue:forget\n// 在当前的队列任务执行完毕后, 重启队列的守护进程\nphp artisan queue:restart\n// 对指定 id 的执行失败的队列任务进行重试(id: 失败队列任务的 ID)\nphp artisan queue:retry id\n// 指定订阅 Iron.io 队列的链接\n// queue: Iron.io 的队列名称.\n// url: 将被订阅的 URL.\n// --type       指定队列的推送类型.\nphp artisan queue:subscribe [--type[="..."]] queue url\n// 处理下一个队列任务\n// --queue      被监听的队列\n// --daemon     在后台模式运行\n// --delay      给执行失败的任务设置延时时间 (默认为零: 0)\n// --force      强制在「维护模式下」运行\n// --memory     内存限制大小，单位为 MB (默认为: 128)\n// --sleep      当没有任务处于有效状态时, 设置其进入休眠的秒数 (默认为: 3)\n// --tries      任务记录失败重试次数 (默认为: 0)\nphp artisan queue:work [--queue[="..."]] [--daemon] [--delay[="..."]] [--force] [--memory[="..."]] [--sleep[="..."]] [--tries[="..."]] [connection]')]),n._v(" "),e("p",[n._v("// 生成路由缓存文件来提升路由效率\nphp artisan route:cache\n// 移除路由缓存文件\nphp artisan route:clear\n// 显示已注册过的路由\nphp artisan route:list")]),n._v(" "),e("p",[n._v("// 运行计划命令\nphp artisan schedule:run")]),n._v(" "),e("p",[n._v('// 为 session 数据表生成迁移文件\nphp artisan session:table\n// 创建 "public/storage" 到 "storage/app/public" 的软链接\nphp artisan storage:link')]),n._v(" "),e("p",[n._v('// 从 vendor 的扩展包中发布任何可发布的资源\n// --force        重写所有已存在的文件\n// --provider     指定你想要发布资源文件的服务提供者\n// --tag          指定你想要发布标记资源.\nphp artisan vendor:publish [--force] [--provider[="..."]] [--tag[="..."]]\nphp artisan tail [--path[="..."]] [--lines[="..."]] [connection]')]),n._v(" "),e("p",[n._v("// 缓存视图文件以提高效率\nphp artisan view:cache\n// 清除视图文件缓存\nphp artisan view:clear")])])}),[],!1,null,null,null);a.default=t.exports}}]);